#!/bin/bash
#
# monitors-search
#
# author: dooley@tacc.utexas.edu
#
# This script is part of the Agave API command line interface (CLI).
# It retrieves a list of monitors based on the search options provided.
#

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

source "$DIR/common.sh"

# Script logic -- TOUCH THIS {{{

# A list of all variables to prompt in interactive mode. These variables HAVE
# to be named exactly as the longname option definition in usage().
interactive_opts=(apisecret apikey)

# Print usage
usage() {
  echo -n "$(basename $0) [OPTION]...
$(basename $0) [OPTION]... [QUERY_TERM]...

Search for monitors based on attribute values. Valid values should be
specified in key pairs such as url.like=*example.com/jobs* or persist=true.
Multiple search terms may be provided as consecutive arguments. For example,
'associatedUuid.in=6642824771244912155-242ac11a-0001-006,7087597638212260326-b0b0b0bb0b-0001-002'
'event.like=*CONTENT_CHANGE*'.

 Query parameters:
  active                        Whether the monitors is actively being run has been a success
  created                       The timestamp when the monitor was first registered. Results are
                                rounded by day. You may specify using YYYY-MM-DD format or free
                                form timeframes such as 'yesterday' or '3 days ago'.
  associateduuid                The uuid of an Agave resource for which this notification will fire.
                                Boolean, default false.
  frequency                     The length between checks performed on the target.
  id                            The unique id of a notification.
  internalusername              The username of the internal users whose credentials will be used to make the check.
  lastcheck.created             The timestamp of the last time an attempt was made for a monitor.
  lastcheck.id                  The id of the last check made for a monitor.
  lastcheck.message             Any warning or error message generated by the last check for a monitor.
  lastcheck.result              The result of the check. Valid values are PASSED or FAILED.
  lastcheck.type                The type of check made. Valid values are STORAGE or EXECUTION.
  lastsuccess                   The timestamp of the last time the monitor check succeeded. Results are
                                rounded by minute. You may specify using YYYY-MM-DD format or free
                                form timeframes such as 'yesterday' or '3 days ago'.
  lastupdated                   The timestamp of the last time the monitor was updated. Results are
                                rounded by minute. You may specify using YYYY-MM-DD format or free
                                form timeframes such as 'yesterday' or '3 days ago'.
  nextupdate                    The timestamp of the next time a monitor check will be made for a monitor.
                                Results will be rounded by minute. You may specify using YYYY-MM-DD format or free
                                form timeframes such as 'yesterday' or '3 days ago'.
  owner                         The username of the principal who originally created the monitor.
  target                        The id of the system to be checked.
  updateSystemStatus            Whether the system status will be updated after a change in check result.

 Options:
  -z, --access_token    Access token
  -l, --limit           Maximum number of results to return
  -o, --offset          Number of results to skip from the start
  -H, --hosturl         URL of the service
  -d, --development     Run in dev mode using default dev server
  -f, --force           Skip all user interaction
  -i, --interactive     Prompt for values
  -q, --quiet           Quiet (no output)
  -v, --verbose         Verbose output
  -V, --veryverbose     Very verbose output
  -h, --help            Display this help and exit
      --version         Output version information and exit
      --rich            Provide rich response
"
}

##################################################################
##################################################################
#						Begin Script Logic						 #
##################################################################
##################################################################

source "$DIR/monitors-common.sh"

main() {
    #echo -n
    # set -x

    hosturl=${hosturl%/}

    querystring=""

    if [ -n "$args" ]; then
        for i in "${args[@]}"
        do
            querystring="${querystring} --data "$(urlencode "${i}" | sed 's/%3D/=/')
        done
    fi

    cmd="curl -G -sk -H \"${authheader}\" '$hosturl?pretty=true$(pagination)' ${querystring}"

    if ((veryverbose)); then
        [ "$piped" -eq 0 ] && log "Calling $cmd"
    fi

    response=`curl -sk -H "${authheader}" "${hosturl}?pretty=true$(pagination)" ${querystring}`

    if [[ $(jsonquery "$response" "status") = 'success' ]]; then
        result=$(format_api_json "$response")
        success "$result"
    else
        errorresponse=$(jsonquery "$response" "message")
        err "$errorresponse"
    fi
}

format_api_json() {

    if ((veryverbose)); then
        echo "$1"
    elif [[ $verbose -eq 1 ]]; then
        result=$(jsonquery "$1" "result" 1)
        json_prettyify "${result}"
    elif [[ $rich -eq 1 ]]; then
        result=$(richify "$1")
        columnize "${result}"      
    else
        if [[ -z "$args" ]]; then
            results=$(jsonquery "$1" "result.[].id")
            echo "$results";
        else
            id=$(jsonquery "$1" "result.id")
            echo "$id"
        fi

    fi
}

##################################################################
##################################################################
#						End Script Logic						 #
##################################################################
##################################################################

# }}}

# Parse command line options
source "$DIR/options.sh"

# Main loop {{{

# Print help if no arguments were passed.
#[[ $# -eq 0 ]] && set -- "--help"

# Read the options and set stuff
while [[ $1 = -?* ]]; do
  case $1 in
    -h|--help) usage >&2; safe_exit ;;
    --version) version; copyright; disclaimer; safe_exit ;;
    -z|--access_token) shift; access_token=$1 ;;
    -U|--uuid) shift; uuid=$1 ;;
    -l|--limit) shift; limit=$1;;
    -o|--offset) shift; offset=$1;;
    --filter) shift; responsefilter=$1 ;;
    -H|--hosturl) shift; hosturl=$1;;
  	-d|--development) development=1 ;;
    -v|--verbose) verbose=1 ;;
    -V|--veryverbose) veryverbose=1; verbose=1 ;;
    -q|--quiet) quiet=1 ;;
    -i|--interactive) interactive=1 ;;
    -f|--force) force=1 ;;
    --rich) rich=1 ;;
    --endopts) shift; break ;;
    *) die "invalid option: $1" ;;
  esac
  shift
done

# Store the remaining part as arguments.
args+=("$@")

# }}}

# Run the script logic
source "$DIR/runner.sh"

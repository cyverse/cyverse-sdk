#!/bin/bash
#
# bash completion file for core docker commands
#
# This script provides completion of:
#  - commands and their options
#  - container ids and names
#  - image repos and tags
#  - filepaths
#
# To enable the completions either:
#  - place this file in /etc/bash_completion.d
#  or
#  - copy this file to e.g. ~/.docker-completion.sh and add the line
#    below to your .bashrc after bash completion features are loaded
#    . ~/.docker-completion.sh
#
# Configuration:
#
# For several commands, the amount of completions can be configured by
# setting environment variables.
#
# AGAVE_CLI_COMPLETION_SHOW_FILES
#   "no"  - Disable autocomplete (default)
#   "yes" - Autocomplete file and folder names
#

CLI_DIR=$(dirname `which clients-create`)

shopt -s extglob

# Handles cache lookup and invalidation for app listing completion checks
_check_cache() {
#    set -x
    source $(which kv-bash)
    local _response _resource _partial _cmd

    _resource=$1; shift
    _partial=$(echo ${1} | sed 's/^"//' | sed 's/"$//'); shift
    _cmd="$CLI_DIR/"$( echo "$@" | sed 's/^"//')

    # force a cache cleanup prior to checking the cache so we don't
    # pull any old data
    _cache_cleanup

    AGAVE_CACHE_VAR="AGAVE_CLI_COMPLETION_CACHE_${_resource}"
    # check the
    if [ -z "${!AGAVE_CACHE_VAR}" ] || [ "${!AGAVE_CACHE_VAR}" = "yes" ]; then
#        set -x
        if [[ -e "$AGAVE_CACHE_DIR/${_resource}-CACHE-${_partial}" ]]; then
            response=$(kvget "${_resource}-CACHE-${_partial}")
        fi

        if [[ -z "$response" ]]; then
            response="$(${_cmd})"
            #echo ${_resource}-CACHE-${_partial}
            kvset "${_resource}-CACHE-${_partial}" "${response}"
        fi
    # set +x
    else
        response="$(${_cmd})"
    fi

    echo $response
#    set +x
}

# calculates cache timeout based on value of the
# AGAVE_CLI_COMPLETION_CACHE_LIFETIME environment variable
#     "" - No value, defaults to 60 (1 hour)
#      0 - Disables cache (default)
#    > 0 - Number of minutes before cache invalidates
_cache_timeout() {
    if [[ -z "$AGAVE_CLI_COMPLETION_CACHE_LIFETIME" ]]; then
        echo 60 # one hour
    elif [[ "$AGAVE_CLI_COMPLETION_CACHE_LIFETIME" -eq 0 ]]; then
        echo 0
    else
        echo "$AGAVE_CLI_COMPLETION_CACHE_LIFETIME"
    fi
}

# removes expired files from the local cache
_cache_cleanup() {
    AGAVE_CACHE_DIR="${AGAVE_CACHE_DIR:-$HOME/.agave}"
    find $AGAVE_CACHE_DIR -type f -mmin +$(_cache_timeout) -iregex ".*-CACHE-.*" | xargs rm -rf
}

# __agave_value_of_option returns the value of the first option matching `option_glob`.
# Valid values for `option_glob` are option names like `--log-level` and globs like
# `--log-level|-l`
# Only positions between the command and the current word are considered.
__agave_value_of_option() {
    local option_extglob=$(__agave_to_extglob "$1")
    local cword=${#COMP_WORDS[@]}

    counter=0
    for word in "${COMP_WORDS[@]}";
    do
        if [[ "${word}" =~ $1 ]];
        then
            echo ${COMP_WORDS[$counter + 1]}
            break;
        fi
        ((counter++))
    done
}

# __agave_append_to_completions appends the word passed as an argument to every
# word in `$COMPREPLY`.
# Normally you do this with `compgen -S` while generating the completions.
# This function allows you to append a suffix later. It allows you to use
# the __docker_complete_XXX functions in cases where you need a suffix.
__agave_append_to_completions() {
    COMPREPLY=( ${COMPREPLY[@]/%/"$1"} )
}

# __agave_to_alternatives transforms a multiline list of strings into a single line
# string with the words separated by `|`.
__agave_to_alternatives() {
    local parts=( $1 )
    local IFS='|'
    echo "${parts[*]}"
}

__agave_flag_exists() {
    for i in "${COMP_WORDS[@]}"; do
        if [[ "$i" == ${1} ]]; then
            echo 1
        fi
    done
}

# __agave_to_extglob transforms a multiline list of options into an extglob pattern
# suitable for use in case statements.
__agave_to_extglob() {
    local extglob=$( __agave_to_alternatives "$1" )
    echo "@($extglob)"
}

_apps_list() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-t|-O|-l|-o|-H|-u|-N|-h|-F) COMPREPLY=($(compgen -f $cur)) ;;
        -n ) COMPREPLY=($(compgen -W "$(apps-search --filter=name -v name.like=${cur}* | grep "\"name\"" | sed 's/"//g' | sed 's/name\://g' | sed 's/ //g')" -- $cur)) ;;
        -S ) COMPREPLY=($(compgen -W "$(systems-search --filter=id name.like=${cur}*)" -- $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'APPS' "LISTINGS" \"apps-list --filter=id\")" -- $cur)) ;;
    esac

}

_apps_clone() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -e) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'execution' \"systems-search --filter=id type=EXECUTION\")" -- $cur)) ;;
        -s) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'storage' \"systems-search --filter=id type=STORAGE id.like=${cur}*\")" -- $cur)) ;;
    # -p
        -z|-n|-x|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'APPS' 'LISTINGS' 'apps-list --filter=id')" -- $cur)) ;;
    esac
}

_apps_pems_update() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -u) COMPREPLY=($(compgen -W "$(profiles-list -v --filter=username -U ${cur} | grep "\"username\"" | sed 's/"//g' | sed 's/username\://g' | sed 's/ //g')" -- $cur)) ;;
        -p) COMPREPLY=($(compgen -W "READ WRITE EXECUTE READ_WRITE READ_EXECUTE WRITE_EXECUTE ALL NONE" -- $cur)) ;;
        -z|-u|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'APPS' 'LISTINGS' 'apps-list --filter=id')" -- $cur)) ;;
    esac
}

_apps_publish() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -e) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'execution' 'systems-search --filter=id type=EXECUTION')" -- $cur)) ;;
        -z|-n|-x|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'APPS' 'LISTINGS' 'apps-list --filter=id')" -- $cur)) ;;
    esac
}

complete -F _apps_list apps-list apps-addupdate apps-delete apps-disable apps-enable apps-erase apps-history apps-pems-delete apps-pems-list jobs-template
complete -F _apps_clone apps-clone
complete -F _apps_pems_update apps-pems-update

# jobs

_jobs_search() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-s|-l|-o|-H|-h|-N|-R|-u) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(jobs-search --filter=id id.like=${cur}*)" -- $cur)) ;;
    esac
}

_jobs_pems_update() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -u) COMPREPLY=($(compgen -W "$(profiles-list -v --filter=username -U ${cur} | grep "\"username\"" | sed 's/"//g' | sed 's/username\://g' | sed 's/ //g')" -- $cur)) ;;
        -p) COMPREPLY=($(compgen -W "READ WRITE READ_WRITE ALL NONE" -- $cur)) ;;
        -z|-u|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(jobs-search --filter=id id.like=${cur}*)" -- $cur)) ;;
    esac
}

_jobs_run_this() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -S) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'LISTING' 'systems-search --filter=id')" -- $cur)) ;;
        *) COMPREPLY=($(compgen -f $cur)) ;;
    esac
}

_jobs_output() {

    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-s|-l|-o|-H|-h|-N|-R|-u) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=( $(_jobs_complete_uuid_our_output_path $cur $prev )) ;;
    esac

}

_jobs_complete_uuid_our_output_path() {
    source $(which common.sh)

    # if the job id has already been provided
    if [[ "$1" =~ -007$ ]]; then

        if [[ "${AGAVE_CLI_COMPLETION_SHOW_JOB_OUTPUTS_PATHS}" = yes ]]; then

            job_id=$1
            shift;
            cur="${1}"

            # get debug option in case we're running against the non-default instance
            _cmd_debug=$(__agave_flag_exists "-d|--debug")
            (( _cmd_debug )) && _debug_flag="-d "

            searchdir=$(echo "${cur}" | sed 's#/$#/.#' | xargs dirname)

            _cmd="$(which jobs-output-list) $_debug_flag -v --filter=name,path,type,_links.self $job_id ${searchdir}"

            file_filter=''
            if [ -n "$cur" ] && [ "$searchdir" != "$cur" ]; then
                file_filter=$(basename "$cur" 2>/dev/null)
            fi

            # force the variable value here so the directory listing is parsed
            AGAVE_CLI_COMPLETION_SHOW_FILE_PATHS=yes && __dir_list  "${_cmd}" | grep "$cur"
        fi

    # otherwise no job id found yet, complete the job id
    else
        compgen -W "$(jobs-search --filter=id id.like=${cur}*)" -- $cur
    fi

}


complete -F _jobs_output jobs-output-get jobs-output-list
complete -F _jobs_search jobs-search jobs-delete jobs-history jobs-kick jobs-pems-list jobs-resubmit jobs-status jobs-stop
complete -F _jobs_pems_update jobs-pems-update
complete -F _jobs_run_this jobs-run-this

# metadata

_metadata_list() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-Q|-P|-l|-o|-H|-h|-u|-F) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(metadata-list -Q '{"uuid":"'${cur}'.*"}')" -- $cur)) ;;
    esac
}

_metadata_pems_addupdate() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -u) COMPREPLY=($(compgen -W "$(profiles-list -v --filter=username -U ${cur} | grep "\"username\"" | sed 's/"//g' | sed 's/username\://g' | sed 's/ //g')" -- $cur)) ;;
        -p) COMPREPLY=($(compgen -W "READ WRITE READ_WRITE ALL NONE" -- $cur)) ;;
        -z|-u|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(metadata-list)" -- $cur)) ;;
    esac
}

_metadata_schema_list() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-Q|-P|-l|-o|-H|-h|F|-D|-u) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(metadata-schema-list -Q '{"uuid":"${cur}.*"}')" -- $cur)) ;;
    esac
}

_metadata_schema_pems_addupdate() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -u) COMPREPLY=($(compgen -W "$(profiles-list -v --filter=username -U ${cur} | grep "\"username\"" | sed 's/"//g' | sed 's/username\://g' | sed 's/ //g')" -- $cur)) ;;
        -p) COMPREPLY=($(compgen -W "READ WRITE READ_WRITE ALL NONE" -- $cur)) ;;
        -z|-u|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(metadata-schema-list -Q '{"uuid":"${cur}.*"}')" -- $cur)) ;;
    esac
}

complete -F _metadata_list metadata-list metadata-addupdate metadata-delete metadata-pems-list
complete -F _metadata_pems_addupdate metadata-pems-addupdate
complete -F _metadata_schema_list metadata-schema-list metadata-schema-addupdate metadata-schema-delete metadata-schema-pems-list
complete -F _metadata_schema_pems_addupdate metadata-schema-pems-addupdate

# monitors

_monitors_list() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -T) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'LISTING' 'systems-search --filter=id')" -- $cur)) ;;
        -z|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$( _check_cache 'MONITORS' 'LISTING' 'monitors-list --filter=id' )" -- $cur)) ;;
    esac
}

_monitors_checks_list() {
    COMPREPLY=()
    local prev cur _monitor_id
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    _monitor_id=$(__agave_value_of_option "--monitorId|-M")
    _monitors_check_cmd="$(echo "monitors-checks-list -M ${_monitor_id} --filter=id")"

#    set -x
    case "$prev" in
        -M) COMPREPLY=($(compgen -W "$(_check_cache 'MONITORS' 'LISTINGS' 'monitors-list --filter=id')" -- $cur)) ;;
        -R) COMPREPLY=($(compgen -W "PASSED FAILED UNKNOWN" -- $cur)) ;;
        -T) COMPREPLY=($(compgen -W "STORAGE LOGIN" -- $cur)) ;;
        -z|-l|-o|-I|-A|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'MONITORS' 'LISTINGS' ${_monitors_check_cmd})" -- $cur)) ;;
    esac
#    set +x
}

_monitors_addupdate() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -S) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'LISTING' 'systems-search --filter=id')" -- $cur)) ;;
        -z|-F|-I|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'MONITORS' 'LISTING' 'monitors-list --filter=id')" -- $cur)) ;;
    esac
}

complete -F _monitors_list monitors-list monitors-delete monitors-fire monitors-history
complete -F _monitors_checks_list monitors-checks-list
complete -F _monitors_addupdate monitors-addupdate

# notifications

_notifications_list() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-U|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'NOTIFICATIONS' 'LISTINGS' 'notifications-search --filter=id')" -- $cur)) ;;
    esac
}

_notifications_list_failures() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}
    _notification_id=$(__agave_value_of_option "--monitorId|-M")
    _notification_list_failure_cmd="$(echo "monitors-checks-list -M ${_monitor_id} --filter=id")"

    case "$prev" in
        -z|-U|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        -N) COMPREPLY=($(compgen -W "$(_check_cache 'NOTIFICATIONS' 'failures' ${_notification_list_failure_cmd})" -- $cur)) ;;
        *) COMPREPLY=($(compgen -f $cur)) ;;
        #*) COMPREPLY=($(compgen -W "$(_check_cache 'NOTIFICATIONS' '' 'notifications-list-failures --filter=id')" -- $cur)) ;;
    esac
}

_notifications_addupdate() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -R) COMPREPLY=($(compgen -W "IMMEDIATE DELAYED EXPONENTIAL" -- $cur)) ;;
        -z|-F|-U|-E|-D|-L|-I|-A|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'NOTIFICATIONS' 'LISTINGS' 'notifications-search --filter=id')" -- $cur)) ;;
    esac
}

complete -F _notifications_list notifications-list notifications-delete notifications-fire notifications-list-failures
complete -F _notifications_addupdate notifications-addupdate

# _postits_list completes the postit nonce on active postits for the user.
_postits_list() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-U|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'POSTITS' 'LISTINGS' 'postits-list --filter=id' | xargs -n 1 sh -c 'echo $0 | sed 's#^.*v2/##g'')" -- $cur)) ;;
    esac
}

# _postits_create completes the postit method on new postits for the user.
_postits_create() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-U|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        -M) COMPREPLY=( $(compgen -W "GET PUT POST DELETE" -- $cur ) ) ;;
        *) COMPREPLY=($(compgen -f $cur)) ;;
    esac
}

complete -F _postits_list postits-list postits-delete
complete -F _postits_create postits-create

# _postits_list completes the postit nonce on active postits for the user.
_postits_list() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-U|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'POSTITS' 'LISTINGS' 'postits-list --filter=id' | xargs -n 1 sh -c 'echo $0 | sed 's#^.*v2/##g'')" -- $cur)) ;;
    esac
}

# _postits_create completes the postit method on new postits for the user.
_postits_create() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-U|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        -M) COMPREPLY=( $(compgen -W "GET PUT POST DELETE" -- $cur ) ) ;;
        *) COMPREPLY=($(compgen -f $cur)) ;;
    esac
}

complete -F _tags-list tags-list tags-delete
complete -F _tags-create tags-create

# _tenants_list
_tenants_list() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -z|-U|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'TENANTS' 'LISTING' 'tenants-list')" -- $cur)) ;;
    esac
}

_tenants_init() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -t) COMPREPLY=( $(compgen -W "$(_check_cache 'TENANTS' 'LISTING' 'tenants-list' |  xargs -n 1 sh -c 'echo $0')" -- $cur) ) ;;
        -z|-U|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -f $cur)) ;;
    esac
}

complete -F _tenants_list tenants-list
complete -F _tenants_init tenants-init

# systems
_systems_list() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}
#    set -x
    case "$prev" in
        -z|-U|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'LISTING' 'systems-search --filter=id')" -- $cur)) ;;
    esac
#set +x
}

_systems_roles_update() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -u) COMPREPLY=($(compgen -W "$(profiles-list -v --filter=username -U ${cur} | grep "\"username\"" | sed 's/"//g' | sed 's/username\://g' | sed 's/ //g')" -- $cur)) ;;
        -p) COMPREPLY=($(compgen -W "GUEST USER PUBLISHER ADMIN OWNER NONE" -- $cur)) ;;
        -z|-u|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'LISTING' 'systems-search --filter=id')" -- $cur)) ;;
    esac
}

complete -F _systems_list systems-list systems-addupdate systems-clone systems-delete systems-erase systems-history systems-disable systems-setdefault systems-unpublish systems-unsetdefault
complete -F _systems_roles_update systems-roles-update systems-roles-delete systems-roles-list systems-credentials-addupdate systems-credentials-list systems-credentials-delete

# profiles commands
_profiles_list() {
    COMPREPLY=()
    local prev cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -E) COMPREPLY=($(compgen -W "$(profiles-list -v --filter=email -E ${cur} | grep "\"email\"" | sed 's/"//g' | sed 's/email\://g' | sed 's/ //g')" -- $cur)) ;;
        -N) COMPREPLY=($(compgen -W "$(profiles-list -v --filter=full_name,fullName -N ${cur} | grep "\"[full_name|fullName]\"" | sed 's/"//g' | sed 's/full_name\://g' | sed 's/fullName\://g' | sed 's/ //g')" -- $cur)) ;;
        -U) COMPREPLY=($(compgen -W "$(profiles-list -v --filter=username -U ${cur} | grep "\"username\"" | sed 's/"//g' | sed 's/username\://g' | sed 's/ //g')" -- $cur)) ;;
        -z|-l|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=($(compgen -W "$(profiles-list -v --filter=username -U ${cur} | grep "\"username\"" | sed 's/"//g' | sed 's/username\://g' | sed 's/ //g')" -- $cur)) ;;
    esac
}

complete -F _profiles_list profiles-list profiles-delete profiles-addpdate

# _files_list handles completion on file path.
# Due to potential performance issues, this is disabled by default.
# You may enable file completion by setting
# AGAVE_CLI_COMPLETION_SHOW_FILE_PATHS
#   "no"  - Disable autocomplete (default)
#   "yes" - Autocomplete file and folder names
_files_list() {
    source $(which common.sh)

    COMPREPLY=()
    local prev cur _searchdir _cmd _cmd_system_id _system_arg _cmd_debug _debug_flag
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    # get the system id for this command
    _cmd_system_id=$(__agave_value_of_option "--system|-S")
    [[ -n "$_cmd_system_id" ]] && _system_arg="-S $_cmd_system_id "

    # get debug option in case we're running against the non-default instance
    _cmd_debug=$(__agave_flag_exists "-d|--debug")
    [[ -n "$_cmd_debug" ]] && _debug_flag="-d "

    searchdir=$(echo "${cur}" | sed 's#/$#/.#' | xargs dirname)
#    cmd=$(echo ${COMP_LINE} | sed 's#--filter=[^ ]* ##g' | sed 's#-V ##g' | sed 's#-v ##g' | sed 's#-L ##g' |sed 's#-l [0-9]*##g' | sed 's#--limit [0-9]*##g' | sed 's#-o [0-9]*##g' | sed 's#-offset [0-9]*##g' | sed 's#--veryverbose ##g' | sed 's#'$cur'#-v --filter=name,path,type,_links.self '${searchdir}'#g')

    _cmd="$(which files-list) $_debug_flag $_system_arg -v --filter=name,path,type,_links.self ${searchdir}"

    file_filter=''
    if [ -n "$cur" ] && [ "$searchdir" != "$cur" ]; then
        file_filter=$(basename $cur 2>/dev/null)
    fi

#    set -x
    case "$prev" in
        -S) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'LISTING' 'systems-search --filter=id')" -- $cur)) ;;
        -z|-l|-L|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=( $( __dir_list  "${_cmd}" | grep "$cur") ) ;;
    esac

}

# _files_pems handles completion on file path, username, and role.
# Due to potential performance issues, this is disabled by default.
# You may enable file completion by setting
# AGAVE_CLI_COMPLETION_SHOW_FILES
#   "no"  - Disable autocomplete (default)
#   "yes" - Autocomplete file and folder names
_files_pems() {
    source $(which common.sh)

    COMPREPLY=()
    local prev cur _searchdir _cmd _cmd_system_id _system_arg _cmd_debug _debug_flag
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    # get the system id for this command
    _cmd_system_id=$(__agave_value_of_option "--system|-S")
    [[ -n "$_cmd_system_id" ]] && _system_arg="-S $_cmd_system_id "

    # get debug option in case we're running against the non-default instance
    _cmd_debug=$(__agave_flag_exists "-d|--debug")
    [[ -n "$_cmd_debug" ]] && _debug_flag="-d "

    searchdir=$(echo "${cur}" | sed 's#/$#/.#' | xargs dirname)

    _cmd="$(which files-list) $_debug_flag $_system_arg -v --filter=name,path,type,_links.self ${searchdir}"

    file_filter=''
    if [ -n "$cur" ] && [ "$searchdir" != "$cur" ]; then
        file_filter=$(basename $cur 2>/dev/null)
    fi

    #    set -x
    case "$prev" in
        -U,-u) COMPREPLY=($(compgen -W "$(profiles-list -v --filter=username -U ${cur} | grep "\"username\"" | sed 's/"//g' | sed 's/username\://g' | sed 's/ //g')" -- $cur)) ;;
        -P,-p) COMPREPLY=($(compgen -W "READ WRITE READ_WRITE ALL NONE" -- $cur)) ;;
        -S) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'LISTING' 'systems-search --filter=id')" -- $cur)) ;;
        -z|-l|-L|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=( $( __dir_list  "${_cmd}" | grep "$cur") ) ;;
    esac
}

# _files_pems handles completion on file path, username, and role.
# Due to potential performance issues, this is disabled by default.
# You may enable file completion by setting
# AGAVE_CLI_COMPLETION_SHOW_FILES
#   "no"  - Disable autocomplete (default)
#   "yes" - Autocomplete file and folder names
_files_import() {
    source $(which common.sh)

    COMPREPLY=()
    local prev cur _searchdir _cmd _cmd_system_id _system_arg _cmd_debug _debug_flag
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    # get the system id for this command
    _cmd_system_id=$(__agave_value_of_option "--system|-S")
    [[ -n "$_cmd_system_id" ]] && _system_arg="-S $_cmd_system_id "

    # get debug option in case we're running against the non-default instance
    _cmd_debug=$(__agave_flag_exists "-d|--debug")
    [[ -n "$_cmd_debug" ]] && _debug_flag="-d "

    searchdir=$(echo "${cur}" | sed 's#/$#/.#' | xargs dirname)

    _cmd="$(which files-list) $_debug_flag $_system_arg -v --filter=name,path,type,_links.self ${searchdir}"

    file_filter=''
    if [ -n "$cur" ] &&  [ "$searchdir" != "$cur" ]; then
        file_filter=$(basename $cur 2>/dev/null)
    fi

    #    set -x
    case "$prev" in
        -U) COMPREPLY=( $( __url_list "$_debug_flag" "${cur}" "${_cmd}" | grep "$cur" ) ) ;;
        -P,-p) COMPREPLY=($(compgen -W "READ WRITE READ_WRITE ALL NONE" -- $cur)) ;;
        -S) COMPREPLY=($(compgen -W "$(_check_cache 'SYSTEMS' 'LISTING' 'systems-search --filter=id')" -- $cur)) ;;
        -z|-l|-L|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=( $( __dir_list  "${_cmd}" | grep "$cur") ) ;;
    esac
}

# __dir_list will replicate the behavior of passing "-o filename" to
# the completion command. This is needed because directory names do not
# come back from the files api with a trailing slash. This function
# will parse the results of a file listing into directory names
# with a trailing slash and file names with no slash.
#
__dir_list() {

    if [ "${AGAVE_CLI_COMPLETION_SHOW_FILE_PATHS}" = yes ];
    then
        # make the actual call
        local ac_response="$(${1})"

        # pull out the values into an array we can randomly access.
        local file_types=($(jsonquery "$ac_response" ".[].type"))
        #local file_names=($(jsonquery "$ac_response" ".[].name"))
        local file_paths=($(jsonquery "$ac_response" ".[].path"))

        # keep an incrementer for referencing name and type fields in
        # the same json response object
        ac_index=-1
        for p in "${file_paths[@]}"; do
            ac_index=$[ac_index+1]
            # pull the path out of the canonical url
#            if is_gnu; then
#                canonical_path=$(echo "$p"| sed 's#.*/\(system\|media\)/[^/]*/##' | sed 's#\(^/*\)##')
#            else
#                canonical_path=$(echo "$p"| sed -E 's#.*/(system|media)/##' | sed -E 's#(^/*)##')
#            fi
            canonical_path="${p}"
            # append trailing slashes to all the directories so we don't
            # get into a closed loop only querying the parent directory
            if [[ "${file_types[$ac_index]}" = "dir" ]]; then
                file_paths[$ac_index]="${canonical_path%/}/"
            # leave file names as they are
            else
                file_paths[$ac_index]="${canonical_path}"
            fi
            echo "${file_paths[$ac_index]}"

        done
#        set +x
    fi
}

__url_list() {

    local _url _debug_flag _cmd _systems
    _debug_flag="$1"
    _url="$2"
    _cmd="${3}"

    # set -x
    if [ "${AGAVE_CLI_COMPLETION_SHOW_FILES}" = yes ];
    then

        # if they gave an empty path, return the systems available
        if [[ -z "${_url}" ]] || [[ "${_url}" = "agave://" ]]; then

            _systems=()
            for i in $(_check_cache 'SYSTEMS' 'LISTING' 'systems-search --filter=id'); do
                _systems+=("agave://${i}/")
            done
            echo "${_systems[@]}"
#            _systems=(${_systems[@]/#/agave://})
#            echo "${_systems[@]/%//}"
#        echo "$_systems"

        # if they gave a paht on their default system
        elif [[ "${_url}" =~ ^/ ]]; then

            _ac_response=$($(which files-list) $_debug_flag  -v --filter=name,path,type,_links.self ${_url})

        # if they gave an agave url
        elif [[ "${_url}" =~ ^agave:// ]]; then

            # look for a system id. it should be the hostname
            _url=${_url#agave://}

            # if the stripped path starts with a slash, an empty system
            # id was given. This references the user default storage system
            if [[ "${_url}" != "${_url#/}" ]]; then

                # extract the system id as the first token in the string
                _system_id=$(echo "${_url}" | sed 's#/.*##')

                # everything after the system id is the path
                _path=${_url#*/}

                # complete system + no path
                if [[ -z "${_path}" ]]; then

                    _systems=( $(_check_cache 'SYSTEMS' 'LISTING' 'systems-search --filter=id')  )
                    _systems=(${_systems[@]/#/agave://})
                    _systems=(${_systems[@]/%//})
                    _systems=($(compgen -W "${_systems[@]}" -- "${2}"))
                    echo "${_systems[@]}"

                # complete system + path
                else

                    # make sure the given system is valid
                    if _sys_exists=$(systems-search --filter=id id.eq=$_system_id | grep $_system_id) ; then

                        # we can call the files api to complete the path without a system id
                        _ac_response=$($(which files-list) "$_debug_flag" -S "${_system_id}" -v --filter=name,path,type,_links.self "${_path}")
                    # otherwise, don't bother autocompleting
                    else
                        echo ""
                        exit
                    fi
                fi

            else
                # strip first character slash. absolute paths will have double slashes after the host
                _path=${_url#/}

                # we can call the files api to complete the path without a system id
                _ac_response=$($(which files-list) "$_debug_flag"  -v --filter=name,path,type,_links.self "${_path}")

            fi

        # otherwise it's a http url. we won't complete it
        else

            echo ""
        fi
        # set -x
        if [[ -n "${_ac_response}" ]]; then

            # pull out the values into an array we can randomly access.
            local file_types=($(jsonquery "$_ac_response" ".[].type"))
            #local file_names=($(jsonquery "$ac_response" ".[].name"))
            local file_paths=($(jsonquery "$_ac_response" ".[].path"))

            # keep an incrementer for referencing name and type fields in
            # the same json response object
            ac_index=-1
            for p in "${file_paths[@]}"; do
                ac_index=$[ac_index+1]
                # pull the path out of the canonical url
                #canonical_path=$(echo "$p"| sed 's#.*/system/[^/]+/##g')
                canonical_path="${p}"

                # append trailing slashes to all the directories so we don't
                # get into a closed loop only querying the parent directory
                if [[ "${file_types[$ac_index]}" = "dir" ]]; then
                    file_paths[$ac_index]="${canonical_path%/}/"
                # leave file names as they are
                else
                    file_paths[$ac_index]="${canonical_path}"
                fi
                echo "${file_paths[$ac_index]}"

            done
        fi
        # set +x
    fi
}

complete -o nospace -F _files_list files-copy files-delete files-get files-history files-import files-index files-list files-mkdir files-move files-publish files-rename files-upload
complete -o nospace -F _files_pems files-pems-list files-pems-update files-pems-delete
#complete -o nospace -F _files_import files-import

# __agave_search provides completion on all `*-search` commands supporting
# the agave search syntax. Search fields are first completed. Upon a match
# completion is provided for search operators. A valid match will result in
# "<field>.<operator>=".
# Note: metadata does not follow standard search syntax and is thus excluded
# from completion in this manner.
#
__agave_search() {

    COMPREPLY=()
    local prev cur _cmd
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}
    cmd="${1##*/}"


    #    echo -e "\nlisting $searchdir for completion options"

    case "$prev" in
        -z|-l|-L|-o|-H|-h) COMPREPLY=($(compgen -f $cur)) ;;
        *) COMPREPLY=( $(compgen -W "$(__agave_append_search_comparator)" -- "${cur}") ) ;;
    esac

}

# __agave_append_search_comparator handles the appending of available search operation terms
# once $cur matches a search term. It is only after a search term has a valid matching operation
# that is will be fully matched with an equal sign appended.
#
__agave_append_search_comparator() {
    # if the current term ends in an equal sign, the term is already
    # complete, so no autocomplete of the term value is needed
    # here we skip completion of terms ending in "="
    if [[ "${cur##*=}" = "${cur}" ]];
    then
        local terms matches results
        terms=$(cat $(which $cmd) | sed -n '/ Query parameters\:/,/ Options/p' | grep -E '^  [a-zA-Z]+' | awk '{print $1}' | xargs -n 1 sh -c 'echo $0' )
        matches=( $(compgen -W "${terms}" -- "${cur%.*}") )

        if [[ "${#matches[@]}" -eq 1 ]]; then

            results=()
            for operator in 'eq' 'neq' 'like' 'nlike' 'in' 'nin' 'gt' 'gte' 'lt' 'lte' 'before' 'after' 'between'
            do
                 results+=("${matches[0]}.${operator}=")
            done
            echo "${results[@]}"
        else
            echo "${matches[@]}"
        fi
    fi
}

complete -o nospace -F __agave_search apps-search jobs-search monitors-search notifications-search systems-search tags-search transfers-search transforms-search groups-search postits-search profiles-search
